---
title: 结合作用域链深入理解闭包
date: 2018-03-18 22:34:10
tags: [JavaScript,作用域,闭包]
---

> 结合作用域链的原理和之前理解的内容对闭包的概念进行更深一步的理解和学习

<!--more-->

## 结合作用域链深入理解闭包
### 相关概念
什么是闭包？

>闭包是指有权访问另外一个函数作用域中的变量的函数  
>                 ————《JavaScript高级程序设计》

闭包的特性
1. 在函数内部嵌套函数
2. 内部函数可以饮用外部执行环境的变量和参数
3. 参数和变量不会被垃圾回收机制回收

闭包的问题
1. 过度使用闭包会导致内存占用过多
2. 闭包只能取得循环中变量的最后一个值

### 1. 作用域链
> 作用域链本质上是一个指向变量对象的指针列表，它只引用但不实际包含变量对象。



#### 1.1 执行环境和活动对象
在函数执行时，会创建一个叫做执行环境/执行上下文的内部对象。执行环境定义了函数及变量能访问的其他数据。每个执行环境中都有一个相关的**变量对象**，环境中所定义的所有变量和函数都保存在这个对象中，编译器在处理数据时会访问这个对象。  
当执行流进入一个函数时，函数的环境就会被推进一个环境栈，而在函数执行完毕后，栈将环境弹出，把控制权返回给之前的执行环境。
- 函数每次执行时的执行环境独一无二
- 多次调用函数就多次创建执行环境
- 函数执行完毕后，执行环境就会被销毁 
![](https://raw.githubusercontent.com/wkd2015/Pic/master/blog/closure_0.png)
当代码在一个环境中执行时，会创建变量对象的一个**作用域链**，用于保证对执行环境有权访问的所有变量和函数的**有序访问**,作用域的前端一直都是当前执行环境的变量对象。如果这个环境是函数的话，那么变量对象就是其活动对象，活动对象最开始只包括arguments对象。作用域链中的下一个变量对象来自其外部环境，以此类推，一直延续到全局变量环境。
#### 1.2 [[scope]]属性
函数内部的[[scope]]属性是虚拟出来的一个属性，保存着**这个函数的父作用域的作用域链**。这个属性对应的是一个对象的列表，列表中的对象仅能javascript内部访问，通过语法访问不到这个属性。  
1. 函数定义时  
在全局环境下定义了一个函数，此时该函数的[[scope]]属性中只包含一个全局对象；当进入函数体执行环境时，在函数体内的函数才被定义，其[[scope]]属性中包含全局对象，及当前活动对象。
2. 函数调用时  
根据执行环境的定义，在函数被调用时，会创建对应的执行环境，每个执行环境对应一个变量对象。
    1. 首先会创建一个自身的活动对象（包含了**this**、参数(arguments)、局部变量(包括命名的参数)的定义）和一个变量对象的作用域链[[scope chain]]
    2. 然后，把这个执行环境的[[scope]]按顺序复制到[[scope chain]]里。
    3. 最后把这个活动对象推入到[[scope chain]]的顶部，这样[[scope chain]]就是一个有序的栈，这样保了对执行环境有权访问的所有变量和对象的有序访问。  

3. 函数执行时  
    - 遇到标识符,就会根据标识符的名称在执行环境(Execution Context)的作用域链中进行搜索。从作用域链的第一个对象（该函数的活动对象）开始，如果没有找到，就搜索作用域链中的下一个对象，如此往复，直到找到了标识符的定义。
    - 随着函数执行过程，逐步沿作用域链进行赋值与查询操作，在完成并返回后函数执行完毕，此时函数执行环境及作用域从对应的栈中弹出。


函数的生命周期：
![](https://raw.githubusercontent.com/wkd2015/Pic/master/blog/closure_1.jpg)

#### 1.3 没有块级作用域
JavaScript是没有块级作用域（if/else/for/while）的，在这些块级作用域上定义的变量和函数是添加到当前执行环境中（函数或全局）的。

### 2. 闭包
结合作用域链的内容，闭包是通过赋值给全局环境下的变量等手段，将函数内部的作用域链及执行环境保存维持下来，使其活动对象不被回收机制回收，且能访问到这个作用域链上所定义的所有变量及参数的函数。
#### 2.1 闭包的实现
```
function foo() {
    var a = 2;
    function bar() { 
        console.log( a );
    }
    return bar;
}
var baz = foo();
baz(); // 2
```
函数bar的词法作用域能够访问foo的内部作用域，然后再把bar函数对象当作一个返回值类型进行传递。在foo执行后，其返回值（bar函数对象）赋值给变量baz，本质上是通过不同的标识符引用了调用了内部作用域的函数bar。
bar所声明的位置决定了它可以访问foo的内部作用域，同时其[[scope]]属性也包含作用域链bar->foo->window，这个作用域链在赋值时会被baz保存下来。
![](https://raw.githubusercontent.com/wkd2015/Pic/master/blog/closure_2.png)
#### 2.2 闭包解决的问题
- 修正循环中取值问题
    ```
    for (var i = 1; i <= 5; i++) {
        setTimeout(function timer() {
            console.log(i);
        }, 1000);
    }
    ```
    上例的输出结果并不是从直观上推断出的1、2、3、4、5，而是输出5个5，其中的原因有两个：  
    1. 首先是setTimeout的执行顺序问题，在上述代码中即使将等待时间设定为0，其输出结果仍然是5个5。其原因是setTimeout在执行时会先推到一个等待队列里，在其他处于等待状态的事件执行完毕后，再“同时”、“立即”调用这些setTimeout，其执行顺序与delay时间相关。因此这段循环的执行顺序是先执行了所有的循环累加过程，再同时调用等待队列中的setTimeout。  
    2. 其次是由于JavaScript不存在块级作用域，因此在代码上看好像是五个不同的i，其实由于这个运行过程是在同一个执行环境中，因此使用的是同一个全局作用域，实际上只有一个i。

    解决方案：
    ```
    for (var i = 1; i <= 5; i++) {
        (function(j) {
            setTimeout(function timer() {
                console.log(j);
            }, j*1000);
        })(i);
    }
    ```
    利用IIFE声明并立即执行一个函数从而创建起一个作用域，解决了setTimeout的执行延迟问题，同时也将全局执行环境中的i作为每一轮的参数传递给每一个迭代函数，从而解决问题。
- 模块
    > 1. 创建私有变量  
    > 2. 模拟块级作用域


1. 利用闭包实现模块

```
function CoolModule() {
    var something = "cool"; 
    var another = [1, 2, 3];
    function doSomething() { 
        console.log( something );
    }
    function doAnother() {
        console.log( another.join( " ! " ) );
    }
    return {
        doSomething: doSomething, 
        doAnother: doAnother
    };
}
var foo = CoolModule(); 
foo.doSomething(); // cool
foo.doAnother(); // 1 ! 2 ! 3
```


首先，CoolModule()只是一个函数，必须要通过调用它来创建一个模块实例。如果不执行外部函数，内部作用域和闭包都无法被创建。  
其次，CoolModule()返回一个用对象字面量语法{ key: value, ... }来表示的对象。这个返回的对象中含有对内部函数而不是内部数据变量的引用。我们保持内部数据变量是隐藏且私有的状态。可以将这个对象类型的返回值看作本质上是模块的公共API。  
这个对象类型的返回值最终被赋值给外部的变量foo，然后就可以通过它来访问API中的属性方法，比如foo.doSomething()。  
> 从模块中返回一个实际的对象并不是必须的，也可以直接返回一个内部函数。jQuery就是一个很好的例子。jQuery和$标识符就是jQuery模块的公共API，但它们本身都是函数（函数也是对象，也可以拥有属性）。



doSomething()和doAnother()函数具有涵盖模块实例内部作用域的闭包（通过调用CoolModule()实现）。当通过返回一个含有属性引用的对象的方式来将函数传递到词法作用域外部时，就已经创造了可以观察和实践闭包的条件。
另外代码中的CoolModule作为模块创建器，每次调用都会创建一个新的模块实例，再需要单例模式时，可以利用IIFE改进来构建：



```
var foo = (function CoolModule() { 
    var something = "cool";
    var another = [1, 2, 3];
    function doSomething() { 
        console.log( something );
    }
    function doAnother() {
        console.log( another.join( " ! " ) );
    }
    return {
        doSomething: doSomething, 
        doAnother: doAnother
    };
})();
foo.doSomething(); // cool 
foo.doAnother(); // 1 ! 2 ! 3
```



2. 现代模块机制
大多数模块依赖加载器/管理器本质上都是将这种模块定义封装进一个友好的API：



```
var MyModules = (function Manager() {
    var modules = {};
    function define(name, deps, impl) {
        for (var i=0; i<deps.length; i++) {
            deps[i] = modules[deps[i]];
        }
        modules[name] = impl.apply( impl, deps );
    }
    function get(name) {
        return modules[name];
    }
    return {
        define: define,
        get: get
    };
})();
```


利用modules[name] = impl.apply(impl, deps)。引入包装函数（可以传入任何依赖），并且将返回值，也就是模块的API，储存在一个根据名字来管理的模块列表中。



```
MyModules.define( "bar", [], function() {
    function hello(who) {
        return "Let me introduce: " + who;
    }
    return {
        hello: hello
    };
} );
MyModules.define( "foo", ["bar"], function(bar) {
    var hungry = "hippo";
    function awesome() {
        console.log( bar.hello( hungry ).toUpperCase() );
    }
    return {
        awesome: awesome
    };
} );
var bar = MyModules.get( "bar" );
var foo = MyModules.get( "foo" );
console.log(
    bar.hello( "hippo" )
); // <i>Let me introduce: hippo</i>
foo.awesome(); // LET ME INTRODUCE: HIPPO
```

### 3. ES6的解决方案
let，const 待更新...


